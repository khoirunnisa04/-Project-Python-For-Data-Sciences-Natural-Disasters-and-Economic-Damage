# -*- coding: utf-8 -*-
"""[Project] Python For Data Sciences

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fwg3tVrcYDpkg5aI9_1WGNe8sTGPdjTW

## **Natural Disasters & Economic Damages**

Import Library
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

"""### Load Data "Number Disasters"
"""

df_number = pd.read_csv("/content/number-of-natural-disaster-events.csv")
df_number.head()

# Drop kolom yang tidak digunakan
df_number = df_number.drop(columns=['Code'])

# Ubah nama Kolom
df_number.rename(columns={"Number of reported natural disasters (reported disasters)": "Reported_Disasters"}, inplace=True)
df_number.head()

"""### Load Data "Economic Damages"
"""

df_economic = pd.read_csv("/content/economic-damage-from-natural-disasters.csv")
df_economic .head()

# Drop kolom yang tidak digunakan
df_economic = df_economic.drop(columns=['Code'])

# Ubah nama Kolom
df_economic.rename(columns={"Total economic damage from natural disasters (US$)": "Economic_Damage"}, inplace=True)
df_economic.head()

"""### **Combine Data**"""

df_naturalDisasters = df_number.merge(df_economic,on=['Entity', 'Year'])
df_naturalDisasters.head()

# Melihat nilai unik di kolom 'Entity'
unique_entities = df_naturalDisasters['Entity'].unique()
print("Unique values in 'Entity':", unique_entities)

"""## Descriptive Statistics"""

df_naturalDisasters.describe()

"""### Melihat Trend

"""

# Mengubah kolom 'Year' menjadi tipe data datetime
df_naturalDisasters['Year'] = pd.to_datetime(df_naturalDisasters['Year'], format='%Y')

# Menghitung jumlah bencana per tahun
disasters_per_year = df_naturalDisasters.groupby('Year')['Reported_Disasters'].sum()

# Plot jumlah bencana per tahun
plt.figure(figsize=(5, 3))
plt.plot(disasters_per_year.index, disasters_per_year.values, color='limegreen')
plt.xlabel('Year', fontsize=10, color='#800000')
plt.ylabel('Number of Reported Disasters', fontsize=10, color='#800000')
plt.title('Trend of Reported Disasters Over Time', fontsize=11, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=40)
plt.show()

# Mengubah kolom 'Year' menjadi tipe data datetime
df_naturalDisasters['Year'] = pd.to_datetime(df_naturalDisasters['Year'], format='%Y')

# Menghitung jumlah bencana per tahun
disasters_per_year = df_naturalDisasters.groupby('Year')['Economic_Damage'].sum()

# Plot jumlah bencana per tahun
plt.figure(figsize=(5, 3))
plt.plot(disasters_per_year.index, disasters_per_year.values, color='green')
plt.xlabel('Year', fontsize=10, color='#800000')
plt.ylabel('Economic Damage', fontsize=10, color='#800000')
plt.title('Trend of Economic Over Time', fontsize=11, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=40)
plt.show()

"""### Melihat Total Keseluruhan"""

# Menghapus semua baris, di mana 'Entity' -nya adalah 'All natural disasters'
# Karena All Natural Disasters merupakan hasil semua rekap data dan dianggap tidak penting
df_naturalDisasters = df_naturalDisasters[df_naturalDisasters['Entity'] != 'All natural disasters']

# Memastikan kolom 'Economic_Damage' adalah tipe data numerik
df_naturalDisasters['Economic_Damage'] = pd.to_numeric(df_naturalDisasters['Economic_Damage'], errors='coerce')

# Menghitung total kerusakan ekonomi per jenis bencana
economic_damage_per_entity = df_naturalDisasters.groupby('Entity')['Economic_Damage'].sum()

# Plot total kerusakan ekonomi per jenis bencana
plt.figure(figsize=(8, 5))
economic_damage_per_entity.sort_values(ascending=False).plot(kind='barh', color='limegreen')
plt.xlabel('Natural Disasters' , fontsize=12, color='#800000')
plt.ylabel('Total Economic Damage', fontsize=12, color='#800000')
plt.title('Total Economic Damage Due to Types of Natural Disasters', fontsize=13, weight="bold")
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

"""## **Simple Linear Regression**"""

# Simple Linear Regression Function
def simple_linear_regression(X, y):
    # Number of observations/points
    n = np.size(X)

    # Mean of x and y vector
    m_X, m_y = np.mean(X), np.mean(y)

    # Calculating cross-deviation and deviation about x
    SS_xy = np.sum(y*X) - n*m_y*m_X
    SS_xx = np.sum(X*X) - n*m_X*m_X

    # Calculating regression coefficients
    b_1 = SS_xy / SS_xx
    b_0 = m_y - b_1*m_X

    return (b_0, b_1)

# Function to show the data points and the regression line
def plot_regression_line(X, y, b):
    # Plotting the actual points as scatter plot
    plt.scatter(X, y, color = "green", marker = "o", s = 70)

    # Predicted response vector
    y_pred = b[0] + b[1]*X

    # Plotting the regression line
    plt.plot(X, y_pred, color = "red")

    # Putting labels for x and y axis
    plt.xlabel('Year')
    plt.ylabel('Monthly Average')

    # Adding a title directly in the set_title function
    plt.gca().set_title('Simple Linear Regression Year & Monthly Average')

    # Function to show plot
    plt.show()

# Assuming that you have a pandas DataFrame df
X = df_naturalDisasters['Reported_Disasters'].values
y = df_naturalDisasters['Economic_Damage'].values

# Getting the regression coefficients
b = simple_linear_regression(X, y)
print("Estimated coefficients:\nb_0 = {}  \nb_1 = {}".format(b[0], b[1]))

# Plotting the regression line and the data points
plt.figure(figsize=(8, 5))
sns.regplot(x='Reported_Disasters', y='Economic_Damage', data=df_naturalDisasters, color='limegreen')
plt.title('Correlation between Reported Disasters & Economic Damage', fontsize=12, weight="bold")
plt.xlabel('Reported Disasters' , fontsize=10, color='#800000')
plt.ylabel('Economic Damage', fontsize=10, color='#800000')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

"""**Hasil Analisis :**

- Dari grafik scatter plot diatas menunjukkan, bahwa ada korelasi positif antara jumlah bencana yang dilaporkan dan kerusakan ekonomi. Ini berarti bahwa semakin banyak bencana yang dilaporkan, semakin besar pula kerusakan ekonomi yang dihasilkan.
- Selain itu, dilihat juga dari data-nya, data tampaknya cukup bervariasi. Meskipun ada tren umum, masih ada banyak titik data yang jauh dari garis tren. Ini menunjukkan bahwa ada banyak variasi dalam data dan bahwa ada banyak bencana dengan kerusakan ekonomi yang relatif rendah atau tinggi, terlepas dari jumlah bencana yang dilaporkan.
- Secara keseluruhan, grafik tersebut memberikan gambaran yang jelas tentang hubungan antara jumlah bencana yang dilaporkan dan kerusakan ekonomi.
"""

# Load Dataset
df = df_number.merge(df_economic,on=['Entity', 'Year'])
df.head()

"""### Membuat Prediksi"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

# Ubah kolom 'Year' menjadi tipe integer
df['Year'] = df['Year'].astype(int)

# Pisahkan data menjadi fitur (X) dan target (y)
X = df[['Year']]
y = df[['Reported_Disasters', 'Economic_Damage']]

# Pisahkan data menjadi set pelatihan dan pengujian
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Buat model regresi linier
model = LinearRegression()

# Latih model dengan data pelatihan
model.fit(X_train, y_train)

# Prediksi target untuk set pengujian
y_pred = model.predict(X_test)

# Hitung kesalahan kuadrat rata-rata (RMSE)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f'Root Mean Squared Error: {rmse}')

# Prediksi untuk tahun mendatang
years = np.array([2025, 2026, 2027, 2028, 2029]).reshape(-1, 1)
future_pred = model.predict(years)

print(f'Predictions for future years: {future_pred}')

# Membuat Prediksi untuk tahun mendatang
years = np.array([2019,2020,2021,2022,2023,2024, 2025, 2026, 2027, 2028, 2029]).reshape(-1, 1)
future_pred = model.predict(years)

# Buat DataFrame baru untuk hasil prediksi
df_pred = pd.DataFrame(future_pred, columns=['Reported_Disasters', 'Economic_Damage'])
df_pred['Year'] = years

print(df_pred)

"""### Perbandingan Nilai Actual & Pedicted"""

import matplotlib.pyplot as plt

# Create two subplots
fig, axs = plt.subplots(2, sharex=True, figsize=(10, 8))


# Create a scatter plot of the actual test values versus the predicted values for 'Reported_Disasters'
axs[0].scatter(X_test, y_test['Reported_Disasters'], color='blue', label='Actual')
axs[0].scatter(X_test, y_pred[:, 0], color='red', label='Predicted')
axs[0].scatter(years, future_pred[:, 0], color='green', label='Future Predicted')
axs[0].set_title('Reported_Disasters')
axs[0].legend()

# Create a scatter plot of the actual test values versus the predicted values for 'Economic_Damage'
axs[1].scatter(X_test, y_test['Economic_Damage'], color='blue', label='Actual')
axs[1].scatter(X_test, y_pred[:, 1], color='red', label='Predicted')
axs[1].scatter(years, future_pred[:, 1], color='green', label='Future Predicted')
axs[1].set_title('Economic_Damage')
axs[1].legend()

# Show the plot
plt.show()

"""## **K-Means**"""

# Load Dataset
df = df_number.merge(df_economic,on=['Entity', 'Year'])
df.head()

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
df['Entity'] = le.fit_transform(df['Entity'])

from sklearn.cluster import KMeans
inertia = []

for i in range(2, 11):
    kmeans = KMeans(n_clusters=i, random_state=0)
    kmeans.fit(df.values)
    inertia.append(kmeans.inertia_)
# print(inertia)


#Visualisasi Inertia
plt.figure(figsize=(7, 4))
# plt.plot(inertia)
plt.plot(range(2, 11), inertia, marker='o', linestyle='-', color='b')
plt.xlabel('Cluster Result')
plt.ylabel('Inertia')
plt.title('Elbow Method')
plt.grid(True)

# Menghitung selisih intertia antar cluster
(pd.Series(inertia) - pd.Series(inertia).shift(-1)) / pd.Series(inertia) * 100

# Apply K-Means Clusterring
kmeans = KMeans(n_clusters=3, random_state=0)
kmeans.fit(df)

df['cluster'] = kmeans.labels_
# df.head()

df['cluster'].unique()

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Memilih kolom 'Reported_Disasters' dan 'Economic_Damage' untuk pengelompokan
X = df[['Reported_Disasters', 'Economic_Damage']]

# Membuat objek KMeans dengan jumlah kluster yang diinginkan
kmeans = KMeans(n_clusters=3)

# Melakukan pengelompokan
kmeans.fit(X)

# Menampilkan DataFrame dengan label kluster
# print(df.head())

cluster0 = df[df['cluster'] == 0]
cluster1 = df[df['cluster'] == 1]
cluster2 = df[df['cluster'] == 2]

plt.scatter(cluster1['Reported_Disasters'],cluster1['Economic_Damage'],label='Cluster 1')
plt.scatter(cluster2['Reported_Disasters'],cluster2['Economic_Damage'],label='Cluster 2')
plt.scatter(cluster0['Reported_Disasters'],cluster0['Economic_Damage'],label='Cluster 0')
plt.legend()

# Visualisasi hasil pengelompokan
plt.gca().set_title('K-Means Clustering Reported_Disasters & Economic_Damage')
plt.xlabel('Reported_Disasters')
plt.ylabel('Economic_Damage')
plt.show()

"""- Klaster Biru (Cluster 1): Klaster ini menunjukkan kerusakan ekonomi tinggi meskipun jumlah bencana yang dilaporkan relatif rendah. Ini bisa berarti bahwa meskipun jumlah bencana yang terjadi tidak banyak, dampaknya terhadap ekonomi sangat signifikan.
- Klaster Oranye (Cluster 2): Klaster ini memiliki kerusakan ekonomi dan jumlah bencana yang dilaporkan di kisaran menengah. Ini bisa berarti bahwa ada keseimbangan antara jumlah bencana yang terjadi dan dampaknya terhadap ekonomi.
- Klaster Hijau (Cluster 0): Klaster ini menunjukkan kerusakan ekonomi rendah dengan jumlah bencana yang dilaporkan juga rendah. Ini bisa berarti bahwa meskipun ada beberapa bencana yang terjadi, dampaknya terhadap ekonomi relatif kecil.
"""

#Menunjukkan centroid dari kmeans
kmeans.cluster_centers_

cluster0.describe()

cluster1.describe()

cluster2.describe()

"""**Lampiran :**

https://www.kaggle.com/datasets/dataenergy/natural-disaster-data
"""